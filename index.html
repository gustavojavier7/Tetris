<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Moderno</title>
    <link href="tetris.css" rel="stylesheet" type="text/css">
    <link href="tetris.ico" rel="shortcut icon">
    <script type="text/javascript" src="tetris.js"></script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>TETRIS <span class="version">v2.90</span></h1>
            <p>Experience the Classic</p>
            <div id="mode-status">MODO: CL√ÅSICO</div>
        </div>
        <div class="main-grid">
            <div class="control-panel">
                <div class="win95-block stats-grid">
                    <div class="stat-card highlight">
                        <label>Score</label>
                        <div class="value" id="tetris-stats-score">0</div>
                    </div>
                    <div class="stat-card">
                        <label>Level</label>
                        <div class="value" id="tetris-stats-level">1</div>
                    </div>
                    <div class="stat-card">
                        <label>Lines</label>
                        <div class="value" id="tetris-stats-lines">0</div>
                    </div>
                    <div class="stat-card">
                        <label>APM</label>
                        <div class="value" id="tetris-stats-apm">0</div>
                    </div>
                </div>

                <div class="win95-block timer-box">
                    <label>Time</label>
                    <div class="value" id="tetris-stats-time">0:00</div>
                </div>

                <div class="win95-block controls">
                    <button class="btn-primary" id="playBtn" onclick="togglePlay()">‚ñ∂ Play</button>
                    <button class="btn-secondary" onclick="restartGame()">‚Üª New Game</button>
                </div>

                <div class="win95-block settings-panel">
                    <div class="settings-header">
                        <p>Game Modes</p>
                        <button class="toggle-btn" onclick="toggleSettingsDetail()" title="Settings">‚öôÔ∏è</button>
                    </div>

                    <div class="mode-switches" id="modeList">
                        <div class="switch-group">
                            <label for="iaAssistToggle">IA-ASSIST</label>
                            <div class="switch" id="iaAssistToggle" onclick="toggleSwitch(this)"></div>
                        </div>
                        <div class="switch-group">
                            <label for="zenToggle">Zen Mode</label>
                            <div class="switch" id="zenToggle" onclick="toggleSwitch(this)"></div>
                        </div>
                    </div>
                </div>

                <div class="win95-block bot-settings hidden" id="botSettings">
                    <div class="bot-settings-header">
                        ‚ö° Bot Strategy
                    </div>
                    <select id="botMode"
                        onchange="if(window.bot && window.bot.setGameplayMode) window.bot.setGameplayMode(window.bot.GamePlayMode[this.value])">
                        <option value="SURVIVAL">SURVIVAL</option>
                        <option value="TETRIS_BUILDER">TETRIS_BUILDER</option>
                        <option value="PRO_ATTACK">PRO_ATTACK</option>
                        <option value="ZEN">ZEN</option>
                        <option value="BALANCED" selected>BALANCED</option>
                    </select>
                </div>

                <button class="btn-secondary" onclick="toggleAudio()" id="audioBtn">üîä Sound On</button>
            </div>
            <div class="game-section">
                <div class="game-board">
                    <div class="inline-next-piece win95-block">
                        <p>Next Piece</p>
                        <div class="next-piece-box" id="tetris-nextpuzzle"></div>
                    </div>
                    <div class="game-grid" id="gameGrid"></div>

                    <div id="tetris-area"></div>

                    <div class="game-message idle" id="gameMessage">
                        <h2>PRESS START</h2>
                        <p>Ready to play?</p>
                    </div>
                </div>
            </div>
        </div>

        <div style="display: none;">
            <div id="tetris-help"></div>
            <div id="tetris-highscores">
                <div id="tetris-highscores-content"></div>
                <span id="tetris-highscores-close"></span>
            </div>
            <span id="tetris-help-close"></span>

            <button id="tetris-menu-start"></button>
            <div id="tetris-pause"><button id="tetris-menu-pause"></button></div>
            <div id="tetris-resume"><button id="tetris-menu-resume"></button></div>
            <button id="tetris-menu-help"></button>
            <button id="tetris-menu-highscores"></button>

            <input type="checkbox" id="tetris-zen-mode">
            <div id="tetris-keys"></div>
        </div>

        <div id="tetris-gameover" style="display:none;"></div>
    </div>

    <script>
        let zoomRatio = 1;
        let gameState = 'idle';
        let isMuted = false;

        var tetris = new Tetris();
        tetris.unit = 20;
        tetris.areaX = 12;
        tetris.areaY = 22;

        if (typeof TetrisBot === 'function') {
            window.bot = new TetrisBot(tetris);
            window.bot.enabled = false;
        }

        // Interceptar teclado: filtrado de eventos cuando la UI tiene el foco
        const UI_FOCUS_SELECTOR = '.control-panel, input, select, textarea, button, .switch, .toggle-btn';
        const LEGACY_GAME_KEYS = new Set([37, 38, 39, 40, 32]); // ‚Üê, ‚Üë, ‚Üí, ‚Üì, Space
        const MODERN_GAME_KEYS = new Set(['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', ' ']);
        const KEY_NAME_TO_CODE = {
            ArrowLeft: 37,
            ArrowUp: 38,
            ArrowRight: 39,
            ArrowDown: 40,
            ' ': 32
        };

        /**
         * Determina si alg√∫n elemento de la UI est√° activo o recibi√≥ el evento.
         * Se usa para evitar que los atajos globales bloqueen al motor cuando no es necesario.
         */
        function uiHasFocus(event) {
            const focused = document.activeElement && document.activeElement !== document.body
                ? document.activeElement
                : null;
            const target = event && event.target && typeof event.target.closest === 'function'
                ? event.target.closest(UI_FOCUS_SELECTOR)
                : null;

            if (target) {
                return true; // Fast-fail: el evento proviene de la UI
            }

            return !!(focused && focused.closest(UI_FOCUS_SELECTOR));
        }

        /**
         * Filtro de teclado en captura: bloquea entradas del juego cuando la UI tiene foco.
         * Tambi√©n previene acciones del navegador (scroll, activaci√≥n accidental) y detiene
         * la propagaci√≥n para evitar duplicados.
         */
        function interceptKeyboard(event) {
            const keyName = typeof event.key === 'string' ? event.key : '';
            const keyCode = typeof event.keyCode === 'number' ? event.keyCode : KEY_NAME_TO_CODE[keyName];

            if (!uiHasFocus(event)) {
                // El foco no est√° en la UI: el motor maneja el teclado sin interferencias externas.
                if (MODERN_GAME_KEYS.has(keyName) || LEGACY_GAME_KEYS.has(keyCode)) {
                    event.preventDefault();
                }
                return;
            }

            // El evento pertenece a la UI: anular comportamiento y evitar que el motor lo lea.
            event.preventDefault();
            if (typeof event.stopImmediatePropagation === 'function') {
                event.stopImmediatePropagation();
            } else {
                event.stopPropagation();
            }
        }

        window.addEventListener('keydown', interceptKeyboard, true);
        window.addEventListener('keyup', interceptKeyboard, true);

        // Evitar que elementos de la UI queden con foco y consuman la barra espaciadora
        document.addEventListener('click', function (e) {
            const uiEl = e.target.closest(UI_FOCUS_SELECTOR);
            if (uiEl) {
                setTimeout(function () {
                    if (document.activeElement && document.activeElement !== document.body) {
                        document.activeElement.blur();
                    }
                }, 0);
            }
        });

        function generateGameGrid() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';
            for (let i = 0; i < 20; i++) {
                const line = document.createElement('div');
                line.className = 'grid-line-h';
                line.style.top = `${(i + 1) * 5}%`;
                grid.appendChild(line);
            }
            for (let i = 0; i < 12; i++) {
                const line = document.createElement('div');
                line.className = 'grid-line-v';
                line.style.left = `${(i + 1) * 8.33}%`;
                grid.appendChild(line);
            }
        }

        function updateGameMessage(state) {
            const message = document.getElementById('gameMessage');
            message.className = 'game-message ' + state;
            message.style.display = 'block';

            switch (state) {
                case 'idle':
                    message.innerHTML = '<h2>PRESS START</h2><p>Ready to play?</p>';
                    break;
                case 'playing':
                    message.style.display = 'none';
                    break;
                case 'paused':
                    message.innerHTML = '<h2>PAUSED</h2>';
                    break;
                case 'gameover':
                    let finalScore = tetris.stats.getScore();
                    message.innerHTML = `<h2>GAME OVER</h2><p>Final Score: ${finalScore}</p>`;
                    break;
            }
        }

        function togglePlay() {
            const btn = document.getElementById('playBtn');

            if (gameState === 'idle' || gameState === 'gameover') {
                gameState = 'playing';
                btn.textContent = '‚è∏ Pause';
                tetris.start();
                updateGameMessage('playing');
            } else if (gameState === 'playing') {
                gameState = 'paused';
                btn.textContent = '‚ñ∂ Resume';
                tetris.pause();
                updateGameMessage('paused');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                btn.textContent = '‚è∏ Pause';
                tetris.pause();
                updateGameMessage('playing');
            }
        }

        function restartGame() {
            const modeState = pushEngineModeState({ coop: false, ia: false, zen: false });
            syncBotSettingsVisibility(modeState);

            tetris.reset();

            if (window.bot) {
                window.bot.enabled = false;
                window.bot.currentPuzzle = null;
                if (typeof window.bot.cancelPlanning === 'function') {
                    window.bot.cancelPlanning();
                }
                if (typeof window.bot.clearGhostPreview === 'function') {
                    window.bot.clearGhostPreview();
                }
            }

            gameState = 'idle';
            document.getElementById('playBtn').textContent = '‚ñ∂ Play';
            updateGameMessage('idle');
        }

        const originalGameOver = tetris.gameOver;
        tetris.gameOver = function () {
            originalGameOver.apply(tetris);
            gameState = 'gameover';
            document.getElementById('playBtn').textContent = '‚ñ∂ Play';
            updateGameMessage('gameover');
        };

        function syncBotController() {
            if (window.bot) {
                window.bot.enabled = (tetris.isCoopMode || tetris.isIAAssist);
            }
        }

        function getEngineModeState() {
            return {
                coop: !!tetris.isCoopMode,
                ia: !!tetris.isIAAssist,
                zen: !!tetris.zenMode
            };
        }

        function pushEngineModeState(modeUpdates) {
            const currentState = getEngineModeState();
            tetris.updateGameMode({
                coop: modeUpdates.coop ?? currentState.coop,
                ia: modeUpdates.ia ?? currentState.ia,
                zen: modeUpdates.zen ?? currentState.zen
            });
            return getEngineModeState();
        }

        function syncBotSettingsVisibility(modeState) {
            const botSettings = document.getElementById('botSettings');
            if (botSettings) {
                botSettings.classList.toggle('hidden', !modeState.ia);
            }
        }

        function toggleSwitch(element) {
            const currentState = getEngineModeState();
            element.classList.toggle('active');
            const isActive = element.classList.contains('active');
            let updatedState = currentState;

            if (element.id === 'iaAssistToggle') {
                updatedState = pushEngineModeState({ ia: isActive });
            } else if (element.id === 'zenToggle') {
                updatedState = pushEngineModeState({ zen: isActive });
            }

            syncBotSettingsVisibility(updatedState);
            syncBotController();
            if (typeof tetris.updateModeStatus === 'function') {
                tetris.updateModeStatus();
            }
        }

        function toggleSettingsDetail() {
            document.getElementById('modeList').classList.toggle('hidden');
        }

        function toggleAudio() {
            isMuted = !isMuted;
            document.getElementById('audioBtn').textContent = isMuted ? 'üîá Sound Off' : 'üîä Sound On';
        }

        function changeBotMode(mode) {
            if (window.bot && window.bot.setGameplayMode) {
                window.bot.setGameplayMode(window.bot.GamePlayMode[mode]);
            }
        }

        window.addEventListener('load', () => {
            generateGameGrid();
            tetris.updateResponsiveUnit();
            document.getElementById('botSettings').classList.add('hidden');
        });

        function fitBoard() {
            const boardContainer = document.querySelector('.game-board');
            const tetrisArea = document.getElementById('tetris-area');

            if (!boardContainer || !tetrisArea) return;

            tetrisArea.style.transform = 'none';

            const availWidth = boardContainer.clientWidth;
            const availHeight = boardContainer.clientHeight;

            const boardWidth = tetrisArea.offsetWidth;
            const boardHeight = tetrisArea.offsetHeight;

            const padding = 20;

            const scaleX = (availWidth - padding) / boardWidth;
            const scaleY = (availHeight - padding) / boardHeight;

            let scale = Math.min(scaleX, scaleY);

            if (scale < 1) {
                tetrisArea.style.transform = `scale(${scale})`;
            } else {
                tetrisArea.style.transform = `scale(1)`;
            }
        }

        window.addEventListener('resize', fitBoard);
        window.addEventListener('load', () => {
            setTimeout(fitBoard, 100);
            setInterval(fitBoard, 2000);
        });
    </script>
</body>

</html>
